# Service Registry
# Defines containerized simulation/compute services available to the agent
#
# Resolution order:
# 1. Check local Docker images
# 2. Pull from GHCR (ghcr.io/sciagent-ai/{name}:latest)
# 3. Build from Dockerfile (services/{name}/Dockerfile)

defaults:
  organization: sciagent-ai
  registry: ghcr.io
  tag: latest

services:
  scipy-base:
    description: "Scientific Python foundation - NumPy, SciPy, Matplotlib, Pandas"
    image: ghcr.io/sciagent-ai/scipy-base
    dockerfile: services/scipy-base/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Numerical computing (numpy)"
      - "Scientific algorithms (scipy)"
      - "Data visualization (matplotlib)"
      - "Data analysis (pandas)"
      - "Unit conversions (pint)"
    example: |
      import numpy as np
      from scipy import optimize, integrate, linalg
      import matplotlib.pyplot as plt
      import pandas as pd

      # Solve equation
      result = optimize.root_scalar(lambda x: x**2 - 2, bracket=[1, 2])
      print(f"sqrt(2) = {result.root}")

      # Integrate function
      integral, _ = integrate.quad(lambda x: np.sin(x), 0, np.pi)
      print(f"∫sin(x)dx from 0 to π = {integral}")

  rdkit:
    description: "RDKit - Cheminformatics toolkit for molecular manipulation and analysis"
    image: ghcr.io/sciagent-ai/rdkit
    dockerfile: services/rdkit/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Molecular structure parsing and manipulation (SMILES, SDF, MOL)"
      - "Molecular fingerprint generation (Morgan, MACCS, etc.)"
      - "Molecular descriptor calculation"
      - "Substructure and similarity searching"
      - "2D/3D coordinate generation"
      - "Reaction handling and transformations"
    example: |
      from rdkit import Chem
      from rdkit.Chem import AllChem, Descriptors, Draw

      # Parse SMILES
      mol = Chem.MolFromSmiles('CCO')  # Ethanol
      print(f"Molecular formula: C{mol.GetNumAtoms()}...")

      # Calculate descriptors
      mw = Descriptors.MolWt(mol)
      logp = Descriptors.MolLogP(mol)
      print(f"MW: {mw:.2f}, LogP: {logp:.2f}")

      # Generate fingerprint
      fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=1024)
      print(f"Morgan fingerprint: {fp.GetNumOnBits()} bits set")

      # Generate 3D coordinates
      AllChem.EmbedMolecule(mol)
      AllChem.MMFFOptimizeMolecule(mol)

  sympy:
    description: "SymPy - Symbolic mathematics for algebraic manipulation, calculus, and equation solving"
    image: ghcr.io/sciagent-ai/sympy
    dockerfile: services/sympy/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Symbolic algebra and simplification"
      - "Calculus (differentiation, integration, limits)"
      - "Equation solving (algebraic, differential)"
      - "Linear algebra (matrices, eigenvalues)"
      - "LaTeX output for mathematical expressions"
      - "Code generation (C, Fortran, Python)"
    example: |
      from sympy import symbols, solve, diff, integrate, simplify, Matrix, latex, sin, exp

      # Define symbols
      x, y = symbols('x y')

      # Solve equation
      solution = solve(x**2 - 2*x - 3, x)
      print(f"x^2 - 2x - 3 = 0 → x = {solution}")

      # Differentiate
      f = x**3 * exp(-x)
      df = diff(f, x)
      print(f"d/dx[x³e^(-x)] = {df}")

      # Integrate
      integral = integrate(sin(x)**2, x)
      print(f"∫sin²(x)dx = {integral}")

      # Matrix operations
      M = Matrix([[1, 2], [3, 4]])
      print(f"Eigenvalues: {M.eigenvals()}")

  cvxpy:
    description: "CVXPY - Convex optimization modeling language for Python"
    image: ghcr.io/sciagent-ai/cvxpy
    dockerfile: services/cvxpy/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Convex optimization problem modeling"
      - "Linear and quadratic programming"
      - "Semidefinite and conic programming"
      - "Portfolio optimization"
      - "Signal processing and control"
      - "Multiple solver backends (OSQP, ECOS, SCS, Clarabel)"
    example: |
      import cvxpy as cp
      import numpy as np

      # Portfolio optimization example
      n = 5  # number of assets
      np.random.seed(1)
      mu = np.random.randn(n)  # expected returns
      Sigma = np.random.randn(n, n)
      Sigma = Sigma @ Sigma.T / n  # covariance matrix

      # Define optimization variables
      w = cp.Variable(n)

      # Define objective: maximize return - risk
      gamma = 0.5  # risk aversion
      objective = cp.Maximize(mu @ w - gamma * cp.quad_form(w, Sigma))

      # Define constraints
      constraints = [cp.sum(w) == 1, w >= 0]

      # Solve
      prob = cp.Problem(objective, constraints)
      prob.solve()
      print(f"Optimal weights: {w.value}")
      print(f"Expected return: {mu @ w.value:.4f}")

  rcwa:
    description: "RCWA/S4 - Rigorous Coupled Wave Analysis for electromagnetic simulations"
    image: ghcr.io/sciagent-ai/s4-rcwa
    dockerfile: services/rcwa/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Photonic crystal simulations"
      - "Diffraction grating analysis"
      - "Multilayer thin film optics"
      - "Scattering matrix calculations"
    example: |
      import S4
      S = S4.New(Lattice=1, NumBasis=20)
      S.SetMaterial('Vacuum', 1)  # Must define Vacuum
      S.SetMaterial('Si', 12+0.1j)
      S.AddLayer('top', 0, 'Vacuum')
      S.AddLayer('slab', 0.5, 'Si')
      S.AddLayerCopy('bottom', 0, 'top')
      S.SetFrequency(1/0.5)
      S.SetExcitationPlanewave((0,0), 1, 0)  # Required before GetPowerFlux
      print(S.GetPowerFlux('bottom'))

  meep:
    description: "MEEP - FDTD electromagnetic simulation"
    image: ghcr.io/sciagent-ai/meep
    dockerfile: services/meep/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Time-domain electromagnetic simulations"
      - "Waveguide design and analysis"
      - "Resonator modeling"
      - "Near-to-far-field transformations"
    example: |
      import meep as mp
      cell = mp.Vector3(16, 8, 0)
      geometry = [mp.Block(mp.Vector3(mp.inf, 1, mp.inf), center=mp.Vector3(), material=mp.Medium(epsilon=12))]
      sources = [mp.Source(mp.ContinuousSource(frequency=0.15), component=mp.Ez, center=mp.Vector3(-7,0))]
      sim = mp.Simulation(cell_size=cell, geometry=geometry, sources=sources, resolution=10)
      sim.run(until=200)

  openfoam:
    description: "OpenFOAM - Computational Fluid Dynamics"
    image: ghcr.io/sciagent-ai/openfoam
    dockerfile: services/openfoam/Dockerfile
    runtime: bash
    workdir: /workspace
    capabilities:
      - "Incompressible and compressible flow"
      - "Turbulence modeling (RANS, LES, DNS)"
      - "Heat transfer simulations"
      - "Multiphase flow"
    example: |
      cd /workspace/cavity
      blockMesh
      icoFoam
      paraFoam

  fenics:
    description: "FEniCS - Finite Element Analysis"
    image: ghcr.io/sciagent-ai/fenics
    dockerfile: services/fenics/Dockerfile
    runtime: python3
    workdir: /workspace
    capabilities:
      - "Partial differential equation solving"
      - "Structural mechanics"
      - "Heat transfer"
      - "Electromagnetics (variational formulation)"
    example: |
      from fenics import *
      mesh = UnitSquareMesh(8, 8)
      V = FunctionSpace(mesh, 'P', 1)
      u = TrialFunction(V)
      v = TestFunction(V)
      f = Constant(-6.0)
      a = dot(grad(u), grad(v))*dx
      L = f*v*dx
      u = Function(V)
      solve(a == L, u)

